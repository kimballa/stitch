# (c) Copyright 2009 Cloudera, Inc.
#
# Classes which take a graph of BuildFiles and
# Targets and generate some output plans; e.g.,
# ant-directed builds, Eclipse workspace generator, etc.

import os
import shutil
import stat

import metamake.antgenerator as antgenerator
import metamake.generator as generator
import metamake.paths as paths
import metamake.propstack as propstack

# the name of the script to emit to do the building.
antprops = propstack.get_properties()
DEFAULT_BUILD_SCRIPT_NAME = "mmbuild"
BUILD_SCRIPT_NAME = antprops.getProperty("build-script", DEFAULT_BUILD_SCRIPT_NAME)


class BuildGenerator(generator.Generator):
  """ Generates a build script which will recursively
      build all the default BuildFile targets in the
      directory underneath this. This is the one
      invoked by metamake by default.

      Automatically supports the following operations:

      build         Compiles sources
      debug         Compiles source in debug mode
      clean         Cleans compiled files
      test          Runs test batteries


      If an ant build file is created, it offers the
      following rules to forward to ant:

      checkstyle    Checks Java code formatting
      pmd           Checks Java for bugs statically
      findbugs      Checks Java for more bugs statically
      static        Run the above three analyses
      ant:target    Forwards "target" to Ant


      If there's a Makefile created, offers the following
      rules to forward to make:

      make:target   Forwards "target" to Make

      If python targets were created, supports the following:
      python-build      Builds python targets
      python-test       Runs python test fixtures
      python-clean      Removes python sources

      If no operation command is given, runs 'build'
      by default.
  """

  def __init__(self):
    generator.Generator.__init__(self)
    self.generators = []

    self.phases = [ ]


  def isPublic(self):
    return True

  def getDescription(self):
    return """BuildGenerator      Creates the top-level build script to
                    build the source tree. (default)"""

  def ensureAntGenerator(self):
    antGen = antgenerator.getAntGenerator()
    try:
      self.generators.index(antGen)
    except ValueError:
      self.generators.append(antGen)


  def generate(self, allTargets):
    """ top-level generate() function. Determines which other
        generators are required and invokes them. """

    print "Creating build scripts..."
    canonical_names = []

    # Clear generation flags
    for target in allTargets:
      target.clearGenerated()

    # Load the necessary generators
    for target in allTargets:
      if target.generatesAntRules():
        # make sure we have an ant generator
        # to handle this
        self.ensureAntGenerator()
        if not target.is_anonymous():
          canonical_names.append(target.getCanonicalName())
        continue
      elif target.isEmpty():
        # handle empty targets automatically
        target.markAsGenerated()
      else:
        # We don't know how to generate this.
        print "Warning: No generator for", target.getCanonicalName()


    # now that we know what generators to invoke, do so.
    for gen in self.generators:
      gen.generate(allTargets)

    # finally, write out the top-level build script
    handle = None
    try:
      try:
        handle = open(BUILD_SCRIPT_NAME, "w")

        # write out our script preamble
        handle.write(self.preamble())

        # write anything into the build script required
        # by our sub-generators
        for gen in self.generators:
          handle.write(gen.getTopLevelScript(allTargets))

        # write out the list of target names.
        handle.write(self.generate_target_list(canonical_names))

        # write out anything that is in the script footer
        handle.write(self.epilogue())

      except IOError, ioe:
        print "Error: Could not write build script:", ioe
    finally:
      if None != handle:
        handle.close()

    # make sure the build script is executable.
    try:
      os.chmod(BUILD_SCRIPT_NAME,
          stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR
          | stat.S_IRGRP | stat.S_IXGRP
          | stat.S_IROTH | stat.S_IXOTH)
    except OSError:
      print "Warning: Could not make build script executable"


  def generate_target_list(self, canonical_names):
    """ Return the text which goes in the script to list all available
        target canonical names
    """

    canonical_names.sort()
    text = "canonical_names = %s\n" % repr(canonical_names)
    text = text + """

def list_targets():
  for name in canonical_names:
    print name

"""

    return text


  def preamble(self):
    """ Return the text which is part of our script header """
    text = """#!/usr/bin/env python
#
# DO NOT EDIT ================================
# This script is autogenerated by metamake
# Any changes to this script should be done
# in the metamake generators
# ============================================

import os
import sys
import shutil

cwd = os.path.abspath(os.getcwd())
base = os.path.abspath(sys.argv[0])
common_path = os.path.commonprefix([cwd, base])

def printUsage():
  print "Usage:", sys.argv[0], "[flags | target ...]"
  print ""
  print "Above, 'target' is the name of any user-defined target."
  print "If no targets are specified, an entire phase is executed;"
  print "the phase may be selected with --phase, or the 'default'"
  print "phase will be run if no arguments are given."
"""
    # Put in the functions for hard-coded targets that
    # always exist.
    text = text + """
  print ""
  print "Flags may be any of the following:"
  print ""
  print "  --phase (name)      Set the phase to run for subsequent targets"
  print ""
  print "  Available phases:"
"""
    all_phases = []
    all_phases.extend(self.phases)
    for gen in self.generators:
      all_phases.extend(gen.getTopLevelRules())

    all_phases.sort()
    for phase in all_phases:
      text = text + "  print \"    " + phase + "\"\n"

    text = text + """
  print ""
  print "  -Dpropname=val      Defines a property which will be passed"
  print "                      to ant for any targets to the right of"
  print "                      the definition on the build command line"
  print ""
  print "  The following flags stop processing of further targets:"
  print ""
  print "  --help              Display this usage information"
  print "  --list              List all available targets"
  print "  --supports (name)   Return 'true' or 'false' if it can"
  print "                      build the named target, and exit with"
  print "                      status '0' or '1' respectively."


props=[]
target_handlers = []
phase_handlers = []

phase = "default"

runFlags = {}
def run(key):
  global runFlags
  try:
    return runFlags[key]
  except KeyError:
    # not present
    return False
"""

    for gen in self.generators:
      text = text + gen.getEnableFlag()

    return text

  def epilogue(self):
    """ Return the text which is our script footer """
    # TODO(aaron): This should use optparse.
    return """

os.chdir(\"""" + paths.getBuildRoot() + """\")

if len(sys.argv) > 1:
  targets = sys.argv[1:]
else:
  targets = []

lookup_only = False
called_target = False
i = 0
while i < len(targets):
  target = targets[i]
  if target == "--help":
    printUsage()
    sys.exit(1)
  elif target.startswith("-D"):
    props.append(target)
  elif target == "--list":
    list_targets()
    sys.exit(1)
  elif target == "--supports":
    lookup_only = True
  elif target == "--phase":
    i = i + 1
    phase = targets[i]
  else:
    # call the user's target
    for handler in target_handlers:
      called_target = False
      try:
        lookup_result = handler(phase, target)
        called_target = True
      except Exception, e:
        # Didn't service this target
        lookup_result = False
    if lookup_only:
      if lookup_result:
        print "true"
        sys.exit(0)
      else:
        print "false"
        sys.exit(1)
    elif not called_target:
      print "Error: Cannot build target", target
      print "Try", sys.argv[0], "--help for usage"
      sys.exit(1)
  i = i + 1

if lookup_only:
  print "Error: requires target name"
  sys.exit(1)
elif not called_target:
  # Do the phase
  for handler in phase_handlers:
    handler(phase)

sys.exit(0)
"""

