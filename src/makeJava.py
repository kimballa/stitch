#!/usr/bin/env python
#
# (c) Copyright 2009 Cloudera, Inc.
#

"""
  makeJava.py --mainclass className --exec executableName --dir pathName
     [--javaopts args]

  creates a script named "executableName" in "pathName" that
  launches className. Finds the appropriate class path entities for this.
"""

import os
import sys

def printUsage():
  print \
 """makeJava.py --mainclass className --exec executableName --dir pathName
    [--javaopts args]

 Creates a script named "executableName" in "pathName" that
 launches className. Automatically configures the classpath with the
 jars in ${pathName} and ${pathName}/lib/"""


def main(argv):
  argv = argv[1:]

  mainClass = None
  exec_name = None
  mainPath = None
  javaOpts = ""
  i = 0
  while i < len(argv):
    if argv[i] == "--mainclass":
      i = i + 1
      mainClass = argv[i]
    elif argv[i] == "--exec":
      i = i + 1
      exec_name = argv[i]
    elif argv[i] == "--dir":
      i = i + 1
      mainPath = argv[i]
    elif argv[i] == "--javaopts":
      i = i + 1
      javaOpts = argv[i]
    elif argv[i] == "--help":
      printUsage()
      return 1
    else:
      print "Unrecognized arg: ", argv[i]
      return 1

    i = i + 1

  if mainClass == None or exec_name == None or mainPath == None:
    print "Missing required argument. Try", sys.argv[0], "--help for usage"
    return 1

  # normalize paths
  mainPath = os.path.realpath(mainPath)
  outputExecName = os.path.join(mainPath, exec_name)
  libdir = os.path.join(mainPath, "lib")

  # find all the .jar files.
  mainPathEntries = os.listdir(mainPath)
  if os.path.exists(libdir):
    libPathEntries = os.listdir(libdir)
  else:
    libPathEntries = []

  jarFiles = []
  for entry in mainPathEntries:
    if entry.endswith(".jar"):
      jarFiles.append(entry)
  for entry in libPathEntries:
    if entry.endswith(".jar"):
      jarFiles.append("lib" + os.sep + entry)

  # TODO: This is not cygwin-safe, because classpath entries are separated
  # by ":". Note that in general we don't support cygwin here really, because
  # we should be using windows-style paths instead of linux-style ones.

  classPath = ""
  first = True
  for jar in jarFiles:
    if not first:
      classPath = classPath + ":"
    first = False
    classPath = classPath + "${bin}" + os.sep + jar

  try:
    handle = open(outputExecName, "w")
    handle.write("""#!/bin/bash
  # AUTOGENERATED FILE
  # DO NOT EDIT
  # This is generated by src/python/Build/makeJava.py
  # Usage: $0 [-mainclass classname] [program-specific arguments]
  bin=`dirname $0`
  bin=`cd ${bin} && pwd`
  PATHELEMS=\"""" + classPath + "\"\n")
    handle.write("mainclass=" + mainClass + "\n")
    handle.write("""if [ "$1" == "-mainclass" ]; then
    shift
    if [ -z "$1" ]; then
      echo "Error: -mainclass requires an argument"
      exit 1
    fi
    mainclass="$1"
    shift
  fi\n""")
    handle.write("java " + javaOpts + " -classpath ${PATHELEMS} $mainclass"
        + " \"$@\"\n")
    handle.close()

    os.chmod(outputExecName, 0755)
  except IOError, ioe:
    print "Could not write to", outputExecName
    print ioe
    return 1
  except OSError, ose:
    print "Could not operate on file", outputExecName
    print ose
    return 1

  return 0




if __name__ == "__main__":
  ret = main(sys.argv)
  sys.exit(ret)
