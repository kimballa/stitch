"""
  stitch.targets.thunks contains 'thunks' which retrieve information about
  targets in a delayed fashion (i.e., you can specify thunks in the construction
  phase but they are forced during the emit phase). You should be able to use
  thunks wherever you can use lists or strings in the parameters.
"""

class Thunk(object):
  """ Represents a delayed computation to be performed in the context of a
      target. By itself this interface class does nothing special. But
      descendents have more interesting 'force()' functions than this one.

      A given thunk may be called multiple times, and it should return
      the same result every time.
  """

  def __init__(self):
    pass


  def force(self, context):
    """  Evalute the thunk within the context of the supplied target
         object ('context'). This may return either a single string,
         or a list of strings.
    """
    # You'll want to override this method.
    return "This Thunk does nothing special"
    

  def str_force(self, context):
    """ Force the thunk and make sure we get a string-based result. """

    result = self.force(context)

    if isinstance(result, list):
      return ",".join(result)
    else
      return result


  def lst_force(self, context):
    """ Force the thunk and make sure we get back a list of results. """

    result = self.force(context)
    if isinstance(result, list):
      return result
    else:
      return [ result ]

    

### Actual Thunk implementations follow ###


class CanonicalName(Thunk):
  """ Returns the canonical name of the target """

  def __init__(self, target_name):
    self.target_name = target_name

  def force(self, context):
    target = context.getTargetByName(self.target_name)
    return target.getCanonicalName()


class AssemblyDir(Thunk):
  """ Returns the assembly dir of a given target """

  def __init__(self, target_name):
    self.target_name = target_name

  def force(self, context):
    target = context.getTargetByName(self.target_name)
    return target.get_assembly_dir()
  

class AssemblyTopDir(Thunk):
  """ Returns the assembly topdir of a given target """

  def __init__(self, target_name):
    self.target_name = target_name

  def force(self, context):
    target = context.getTargetByName(self.target_name)
    return target.get_assembly_top_dir()
  
 
class SrcDir(Thunk):
  """ Returns the srcdir of a given target """

  def __init__(self, target_name):
    self.target_name = target_name

  def force(self, context):
    target = context.getTargetByName(self.target_name)
    return target.getInputDirectory()
  

class ClassPathElements(Thunk):
  """ Returns the classpath element requirements of a given target """

  def __init__(self, target_name):
    self.target_name = target_name

  def force(self, context):
    target = context.getTargetByName(self.target_name)
    return target.getClassPathElements()
  

class RequiredTargets(Thunk):
  """ Returns the names of the dependencies of a given target """

  def __init__(self, target_name):
    self.target_name = target_name

  def force(self, context):
    target = context.getTargetByName(self.target_name)
    reqs = target.required_targets
    if reqs is None:
      return []
    else:
      return reqs


class Outputs(Thunk):
  """ Returns a list of paths to output objects generated by a target """

  def __init__(self, target_name):
    self.target_name = target_name

  def force(self, context):
    target = context.getTargetByName(self.target_name)
    return target.outputPaths()


### The following thunks operate on other thunks. ###

class FirstElem(Thunk):
  """ Takes only a single entry from a list thunk and returns it (as a string) """

  def __init__(self, subthunk):
    self.subthunk = subthunk

  def force(self, context):
    results = self.subthunk.force(context)
    if isinstance(results, list):
      if len(results) == 0:
        return ""
      else:
        return results[0]
    else:
      # It's already a string.
      return results


class ToList(Thunk):
  """ Ensures that the output of a thunk is a list """

  def __init__(self, subthunk):
    self.subthunk = subthunk

  def force(self, context):
    return self.subthunk.lst_force(context)


